// This file is auto-generated by @hey-api/openapi-ts

import { client } from "./client.gen.js"
import { buildClientParams, type Client, type Options as Options2, type TDataShape } from "./client/index.js"
import type {
  AgentPartInput,
  AppAgentsResponses,
  AppLogErrors,
  AppLogResponses,
  Auth as Auth4,
  AuthRemoveErrors,
  AuthRemoveResponses,
  AuthSetErrors,
  AuthSetResponses,
  CommandListResponses,
  Config as Config2,
  ConfigGetResponses,
  ConfigProvidersResponses,
  ConfigUpdateErrors,
  ConfigUpdateResponses,
  EventGlobalResponses,
  EventsGlobalResponses,
  EventSubscribeResponses,
  EventTuiCommandExecute,
  EventTuiPromptAppend,
  EventTuiSessionSelect,
  EventTuiToastShow,
  ExperimentalResourceListResponses,
  FileListResponses,
  FilePartInput,
  FilePartSource,
  FileReadResponses,
  FileStatusResponses,
  FindFilesResponses,
  FindSymbolsResponses,
  FindTextResponses,
  FormatterStatusResponses,
  GatewayTelegramSendResponses,
  GatewayWhatsappSendResponses,
  HealthCheckResponses,
  HealthStatusResponses,
  InstanceDispose2Responses,
  InstanceDisposeResponses,
  LspStatusResponses,
  McpAddErrors,
  McpAddResponses,
  McpAuthAuthenticateErrors,
  McpAuthAuthenticateResponses,
  McpAuthCallbackErrors,
  McpAuthCallbackResponses,
  McpAuthRemoveErrors,
  McpAuthRemoveResponses,
  McpAuthStartErrors,
  McpAuthStartResponses,
  McpConnectResponses,
  McpDisconnectResponses,
  McpHealthCheckAndReconnectResponses,
  McpLocalConfig,
  McpReconnectAllResponses,
  McpReconnectResponses,
  McpRemoteConfig,
  McpStatusResponses,
  McpToolCallErrors,
  McpToolCallResponses,
  MemoryBatchErrors,
  MemoryBatchResponses,
  MemoryByNamespaceResponses,
  MemoryCleanupResponses,
  MemoryDeleteResponses,
  MemoryDeleteWhereErrors,
  MemoryDeleteWhereResponses,
  MemoryGetErrors,
  MemoryGetResponses,
  MemoryHealthResponses,
  MemoryResetResponses,
  MemorySearchErrors,
  MemorySearchResponses,
  MemoryStatsResponses,
  MemoryStoreErrors,
  MemoryStoreResponses,
  OpenapiSpecsResponses,
  Part as Part2,
  PartDeleteErrors,
  PartDeleteResponses,
  PartUpdateErrors,
  PartUpdateResponses,
  PathGetResponses,
  PermissionListResponses,
  PermissionReplyErrors,
  PermissionReplyResponses,
  PermissionRespondErrors,
  PermissionRespondResponses,
  PermissionRuleset,
  PersonasListResponses,
  PreferencesThemeGetResponses,
  PreferencesThemeSetErrors,
  PreferencesThemeSetResponses,
  ProcessBySwarmResponses,
  ProcessDeregisterErrors,
  ProcessDeregisterResponses,
  ProcessEventsResponses,
  ProcessFindAvailableResponses,
  ProcessGetErrors,
  ProcessGetResponses,
  ProcessHeartbeatErrors,
  ProcessHeartbeatResponses,
  ProcessListResponses,
  ProcessRegisterErrors,
  ProcessRegisterResponses,
  ProcessStatsResponses,
  ProcessUpdateErrors,
  ProcessUpdateResponses,
  ProjectCurrentResponses,
  ProjectListResponses,
  ProjectUpdateErrors,
  ProjectUpdateResponses,
  ProviderAuthResponses,
  ProviderAuthStatusResponses,
  ProviderListResponses,
  ProviderOauthAuthorizeErrors,
  ProviderOauthAuthorizeResponses,
  ProviderOauthCallbackErrors,
  ProviderOauthCallbackResponses,
  PtyCreateErrors,
  PtyCreateResponses,
  PtyGetErrors,
  PtyGetResponses,
  PtyListResponses,
  PtyRemoveResponses,
  PtyUpdateErrors,
  PtyUpdateResponses,
  QuestionAnswer,
  QuestionListResponses,
  QuestionRejectErrors,
  QuestionRejectResponses,
  QuestionReplyErrors,
  QuestionReplyResponses,
  SessionAbortErrors,
  SessionAbortResponses,
  SessionChildrenErrors,
  SessionChildrenResponses,
  SessionCommandErrors,
  SessionCommandResponses,
  SessionCreateErrors,
  SessionCreateResponses,
  SessionDeleteErrors,
  SessionDeleteResponses,
  SessionDiffAllErrors,
  SessionDiffAllResponses,
  SessionDiffResponses,
  SessionEventsErrors,
  SessionEventsResponses,
  SessionForkResponses,
  SessionGetErrors,
  SessionGetResponses,
  SessionHandoffErrors,
  SessionHandoffResponses,
  SessionInitErrors,
  SessionInitResponses,
  SessionListResponses,
  SessionMessageErrors,
  SessionMessageResponses,
  SessionMessagesErrors,
  SessionMessagesResponses,
  SessionPromptAsyncErrors,
  SessionPromptAsyncResponses,
  SessionPromptErrors,
  SessionPromptResponses,
  SessionRevertErrors,
  SessionRevertResponses,
  SessionShareErrors,
  SessionShareResponses,
  SessionShellErrors,
  SessionShellResponses,
  SessionStatusErrors,
  SessionStatusResponses,
  SessionSummarizeErrors,
  SessionSummarizeResponses,
  SessionTodoErrors,
  SessionTodoResponses,
  SessionUnrevertErrors,
  SessionUnrevertResponses,
  SessionUnshareErrors,
  SessionUnshareResponses,
  SessionUpdateErrors,
  SessionUpdateResponses,
  SubtaskPartInput,
  SyncDeltaResponses,
  TextPartInput,
  ThemesListResponses,
  ToolIdsErrors,
  ToolIdsResponses,
  ToolListErrors,
  ToolListResponses,
  TuiAppendPromptErrors,
  TuiAppendPromptResponses,
  TuiClearPromptResponses,
  TuiExecuteCommandErrors,
  TuiExecuteCommandResponses,
  TuiOpenHelpResponses,
  TuiOpenModelsResponses,
  TuiOpenSessionsResponses,
  TuiOpenThemesResponses,
  TuiPublishErrors,
  TuiPublishResponses,
  TuiSelectSessionErrors,
  TuiSelectSessionResponses,
  TuiShowToastResponses,
  TuiSubmitPromptResponses,
  VcsGetResponses,
  WorktreeCreateErrors,
  WorktreeCreateInput,
  WorktreeCreateResponses,
  WorktreeListResponses,
} from "./types.gen.js"

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<
  TData,
  ThrowOnError
> & {
  /**
   * You can provide a client instance returned by `createClient()` instead of
   * individual options. This might be also useful if you want to implement a
   * custom client.
   */
  client?: Client
  /**
   * You can pass arbitrary values through the `meta` object. This can be
   * used to access values that aren't defined as part of the SDK function.
   */
  meta?: Record<string, unknown>
}

class HeyApiClient {
  protected client: Client

  constructor(args?: { client?: Client }) {
    this.client = args?.client ?? client
  }
}

class HeyApiRegistry<T> {
  private readonly defaultKey = "default"

  private readonly instances: Map<string, T> = new Map()

  get(key?: string): T {
    const instance = this.instances.get(key ?? this.defaultKey)
    if (!instance) {
      throw new Error(`No SDK client found. Create one with "new OpencodeClient()" to fix this error.`)
    }
    return instance
  }

  set(value: T, key?: string): void {
    this.instances.set(key ?? this.defaultKey, value)
  }
}

export class Event extends HeyApiClient {
  /**
   * Subscribe to events
   *
   * Get events
   */
  public subscribe<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<EventSubscribeResponses, unknown, ThrowOnError>({
      url: "/event",
      ...options,
    })
  }

  /**
   * Global event stream (SSE)
   *
   * Subscribe to all global events via Server-Sent Events. Useful for dashboards and cross-platform monitoring.
   */
  public global<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<EventGlobalResponses, unknown, ThrowOnError>({
      url: "/global/event",
      ...options,
    })
  }
}

export class App extends HeyApiClient {
  /**
   * Write log
   *
   * Write a log entry to the server logs with specified level and metadata.
   */
  public log<ThrowOnError extends boolean = false>(
    parameters?: {
      service?: string
      level?: "debug" | "info" | "error" | "warn"
      message?: string
      extra?: {
        [key: string]: unknown
      }
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "body", key: "service" },
            { in: "body", key: "level" },
            { in: "body", key: "message" },
            { in: "body", key: "extra" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<AppLogResponses, AppLogErrors, ThrowOnError>({
      url: "/log",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * List agents
   *
   * Get a list of all available AI agents in the agent-core system.
   */
  public agents<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<AppAgentsResponses, unknown, ThrowOnError>({
      url: "/agent",
      ...options,
    })
  }
}

export class Health extends HeyApiClient {
  /**
   * Health check
   *
   * Check if the server is running and healthy.
   */
  public check<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<HealthCheckResponses, unknown, ThrowOnError>({
      url: "/global/health",
      ...options,
    })
  }

  /**
   * System health status
   *
   * Get internet connectivity and LLM provider status for system monitoring.
   */
  public status<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<HealthStatusResponses, unknown, ThrowOnError>({
      url: "/global/health/status",
      ...options,
    })
  }
}

export class Instance extends HeyApiClient {
  /**
   * Dispose instance
   *
   * Clean up and dispose the current agent-core instance, releasing all resources.
   */
  public dispose<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).post<InstanceDisposeResponses, unknown, ThrowOnError>({
      url: "/global/dispose",
      ...options,
    })
  }

  /**
   * Dispose instance
   *
   * Clean up and dispose the current agent-core instance, releasing all resources.
   */
  public dispose2<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).post<InstanceDispose2Responses, unknown, ThrowOnError>({
      url: "/instance/dispose",
      ...options,
    })
  }
}

export class Pty extends HeyApiClient {
  /**
   * List PTY sessions
   *
   * Get a list of all active pseudo-terminal (PTY) sessions managed by agent-core.
   */
  public list<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<PtyListResponses, unknown, ThrowOnError>({ url: "/pty", ...options })
  }

  /**
   * Create PTY session
   *
   * Create a new pseudo-terminal (PTY) session for running shell commands and processes.
   */
  public create<ThrowOnError extends boolean = false>(
    parameters?: {
      command?: string
      args?: Array<string>
      cwd?: string
      title?: string
      env?: {
        [key: string]: string
      }
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "body", key: "command" },
            { in: "body", key: "args" },
            { in: "body", key: "cwd" },
            { in: "body", key: "title" },
            { in: "body", key: "env" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<PtyCreateResponses, PtyCreateErrors, ThrowOnError>({
      url: "/pty",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Remove PTY session
   *
   * Remove and terminate a specific pseudo-terminal (PTY) session.
   */
  public remove<ThrowOnError extends boolean = false>(
    parameters: {
      ptyID: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "ptyID" }] }])
    return (options?.client ?? this.client).delete<PtyRemoveResponses, unknown, ThrowOnError>({
      url: "/pty/{ptyID}",
      ...options,
      ...params,
    })
  }

  /**
   * Get PTY session
   *
   * Retrieve detailed information about a specific pseudo-terminal (PTY) session.
   */
  public get<ThrowOnError extends boolean = false>(
    parameters: {
      ptyID: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "ptyID" }] }])
    return (options?.client ?? this.client).get<PtyGetResponses, PtyGetErrors, ThrowOnError>({
      url: "/pty/{ptyID}",
      ...options,
      ...params,
    })
  }

  /**
   * Update PTY session
   *
   * Update properties of an existing pseudo-terminal (PTY) session.
   */
  public update<ThrowOnError extends boolean = false>(
    parameters: {
      ptyID: string
      title?: string
      size?: {
        rows: number
        cols: number
      }
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "ptyID" },
            { in: "body", key: "title" },
            { in: "body", key: "size" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).put<PtyUpdateResponses, PtyUpdateErrors, ThrowOnError>({
      url: "/pty/{ptyID}",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }
}

export class Config extends HeyApiClient {
  /**
   * Get configuration
   *
   * Retrieve the current agent-core configuration settings and preferences.
   */
  public get<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<ConfigGetResponses, unknown, ThrowOnError>({
      url: "/config",
      ...options,
    })
  }

  /**
   * Update configuration
   *
   * Update agent-core configuration settings and preferences.
   */
  public update<ThrowOnError extends boolean = false>(
    parameters?: {
      config?: Config2
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ key: "config", map: "body" }] }])
    return (options?.client ?? this.client).patch<ConfigUpdateResponses, ConfigUpdateErrors, ThrowOnError>({
      url: "/config",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * List config providers
   *
   * Get a list of all configured AI providers and their default models.
   */
  public providers<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<ConfigProvidersResponses, unknown, ThrowOnError>({
      url: "/config/providers",
      ...options,
    })
  }
}

export class Themes extends HeyApiClient {
  /**
   * List available themes
   *
   * Get a list of all available themes for the interface.
   */
  public list<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<ThemesListResponses, unknown, ThrowOnError>({
      url: "/themes",
      ...options,
    })
  }
}

export class Theme extends HeyApiClient {
  /**
   * Get current theme
   *
   * Get the current theme setting.
   */
  public get<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<PreferencesThemeGetResponses, unknown, ThrowOnError>({
      url: "/preferences/theme",
      ...options,
    })
  }

  /**
   * Set theme
   *
   * Update the current theme setting.
   */
  public set<ThrowOnError extends boolean = false>(
    parameters?: {
      theme?: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "body", key: "theme" }] }])
    return (options?.client ?? this.client).patch<
      PreferencesThemeSetResponses,
      PreferencesThemeSetErrors,
      ThrowOnError
    >({
      url: "/preferences/theme",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }
}

export class Preferences extends HeyApiClient {
  private _theme?: Theme
  get theme(): Theme {
    return (this._theme ??= new Theme({ client: this.client }))
  }
}

export class Path extends HeyApiClient {
  /**
   * Get paths
   *
   * Retrieve the current working directory and related path information for the agent-core instance.
   */
  public get<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<PathGetResponses, unknown, ThrowOnError>({ url: "/path", ...options })
  }
}

export class Worktree extends HeyApiClient {
  /**
   * List worktrees
   *
   * List all sandbox worktrees for the current project.
   */
  public list<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<WorktreeListResponses, unknown, ThrowOnError>({
      url: "/experimental/worktree",
      ...options,
    })
  }

  /**
   * Create worktree
   *
   * Create a new git worktree for the current project.
   */
  public create<ThrowOnError extends boolean = false>(
    parameters?: {
      worktreeCreateInput?: WorktreeCreateInput
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ key: "worktreeCreateInput", map: "body" }] }])
    return (options?.client ?? this.client).post<WorktreeCreateResponses, WorktreeCreateErrors, ThrowOnError>({
      url: "/experimental/worktree",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }
}

export class Vcs extends HeyApiClient {
  /**
   * Get VCS info
   *
   * Retrieve version control system (VCS) information for the current project, such as git branch.
   */
  public get<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<VcsGetResponses, unknown, ThrowOnError>({ url: "/vcs", ...options })
  }
}

export class Find extends HeyApiClient {
  /**
   * Find text
   *
   * Search for text patterns across files in the project using ripgrep.
   */
  public text<ThrowOnError extends boolean = false>(
    parameters: {
      pattern: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "query", key: "pattern" }] }])
    return (options?.client ?? this.client).get<FindTextResponses, unknown, ThrowOnError>({
      url: "/find",
      ...options,
      ...params,
    })
  }

  /**
   * Find files
   *
   * Search for files or directories by name or pattern in the project directory.
   */
  public files<ThrowOnError extends boolean = false>(
    parameters: {
      query: string
      dirs?: "true" | "false"
      type?: "file" | "directory"
      limit?: number
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "query", key: "query" },
            { in: "query", key: "dirs" },
            { in: "query", key: "type" },
            { in: "query", key: "limit" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).get<FindFilesResponses, unknown, ThrowOnError>({
      url: "/find/file",
      ...options,
      ...params,
    })
  }

  /**
   * Find symbols
   *
   * Search for workspace symbols like functions, classes, and variables using LSP.
   */
  public symbols<ThrowOnError extends boolean = false>(
    parameters: {
      query: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "query", key: "query" }] }])
    return (options?.client ?? this.client).get<FindSymbolsResponses, unknown, ThrowOnError>({
      url: "/find/symbol",
      ...options,
      ...params,
    })
  }
}

export class File extends HeyApiClient {
  /**
   * List files
   *
   * List files and directories in a specified path.
   */
  public list<ThrowOnError extends boolean = false>(
    parameters: {
      path: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "query", key: "path" }] }])
    return (options?.client ?? this.client).get<FileListResponses, unknown, ThrowOnError>({
      url: "/file",
      ...options,
      ...params,
    })
  }

  /**
   * Read file
   *
   * Read the content of a specified file.
   */
  public read<ThrowOnError extends boolean = false>(
    parameters: {
      path: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "query", key: "path" }] }])
    return (options?.client ?? this.client).get<FileReadResponses, unknown, ThrowOnError>({
      url: "/file/content",
      ...options,
      ...params,
    })
  }

  /**
   * Get file status
   *
   * Get the git status of all files in the project.
   */
  public status<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<FileStatusResponses, unknown, ThrowOnError>({
      url: "/file/status",
      ...options,
    })
  }
}

export class Session extends HeyApiClient {
  /**
   * List sessions
   *
   * Get a list of all agent-core sessions, sorted by most recently updated.
   */
  public list<ThrowOnError extends boolean = false>(
    parameters?: {
      start?: number
      search?: string
      limit?: number
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "query", key: "start" },
            { in: "query", key: "search" },
            { in: "query", key: "limit" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).get<SessionListResponses, unknown, ThrowOnError>({
      url: "/session",
      ...options,
      ...params,
    })
  }

  /**
   * Create session
   *
   * Create a new agent-core session for interacting with AI assistants and managing conversations.
   */
  public create<ThrowOnError extends boolean = false>(
    parameters?: {
      parentID?: string
      title?: string
      permission?: PermissionRuleset
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "body", key: "parentID" },
            { in: "body", key: "title" },
            { in: "body", key: "permission" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<SessionCreateResponses, SessionCreateErrors, ThrowOnError>({
      url: "/session",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Get session messages
   *
   * Retrieve all messages in a session, including user prompts and AI responses.
   */
  public messages<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
      limit?: number
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "sessionID" },
            { in: "query", key: "limit" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).get<SessionMessagesResponses, SessionMessagesErrors, ThrowOnError>({
      url: "/session/{sessionID}/message",
      ...options,
      ...params,
    })
  }

  /**
   * Send message
   *
   * Create and send a new message to a session, streaming the AI response.
   */
  public prompt<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
      messageID?: string
      model?: {
        providerID: string
        modelID: string
      }
      agent?: string
      noReply?: boolean
      tools?: {
        [key: string]: boolean
      }
      system?: string
      options?: {
        [key: string]: unknown
      }
      variant?: string
      parts?: Array<TextPartInput | FilePartInput | AgentPartInput | SubtaskPartInput>
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "sessionID" },
            { in: "body", key: "messageID" },
            { in: "body", key: "model" },
            { in: "body", key: "agent" },
            { in: "body", key: "noReply" },
            { in: "body", key: "tools" },
            { in: "body", key: "system" },
            { in: "body", key: "options" },
            { in: "body", key: "variant" },
            { in: "body", key: "parts" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<SessionPromptResponses, SessionPromptErrors, ThrowOnError>({
      url: "/session/{sessionID}/message",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Get session status
   *
   * Retrieve the current status of all sessions, including active, idle, and completed states.
   */
  public status<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<SessionStatusResponses, SessionStatusErrors, ThrowOnError>({
      url: "/session/status",
      ...options,
    })
  }

  /**
   * Delete session
   *
   * Delete a session and permanently remove all associated data, including messages and history.
   */
  public delete<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "sessionID" }] }])
    return (options?.client ?? this.client).delete<SessionDeleteResponses, SessionDeleteErrors, ThrowOnError>({
      url: "/session/{sessionID}",
      ...options,
      ...params,
    })
  }

  /**
   * Get session
   *
   * Retrieve detailed information about a specific agent-core session.
   */
  public get<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "sessionID" }] }])
    return (options?.client ?? this.client).get<SessionGetResponses, SessionGetErrors, ThrowOnError>({
      url: "/session/{sessionID}",
      ...options,
      ...params,
    })
  }

  /**
   * Update session
   *
   * Update properties of an existing session, such as title or other metadata.
   */
  public update<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
      title?: string
      time?: {
        archived?: number
      }
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "sessionID" },
            { in: "body", key: "title" },
            { in: "body", key: "time" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).patch<SessionUpdateResponses, SessionUpdateErrors, ThrowOnError>({
      url: "/session/{sessionID}",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Session handoff
   *
   * Prepare a session for handoff to another platform (mobile, web). Returns session state and a handoff token for resumption.
   */
  public handoff<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
      targetSurface?: "mobile" | "web" | "cli" | "telegram" | "whatsapp"
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "sessionID" },
            { in: "body", key: "targetSurface" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<SessionHandoffResponses, SessionHandoffErrors, ThrowOnError>({
      url: "/session/{sessionID}/handoff",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Get session todos
   *
   * Retrieve the todo list associated with a specific session, showing tasks and action items.
   */
  public todo<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "sessionID" }] }])
    return (options?.client ?? this.client).get<SessionTodoResponses, SessionTodoErrors, ThrowOnError>({
      url: "/session/{sessionID}/todo",
      ...options,
      ...params,
    })
  }

  /**
   * Initialize session
   *
   * Analyze the current application and create an AGENTS.md file with project-specific agent configurations.
   */
  public init<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
      modelID?: string
      providerID?: string
      messageID?: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "sessionID" },
            { in: "body", key: "modelID" },
            { in: "body", key: "providerID" },
            { in: "body", key: "messageID" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<SessionInitResponses, SessionInitErrors, ThrowOnError>({
      url: "/session/{sessionID}/init",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Fork session
   *
   * Create a new session by forking an existing session at a specific message point.
   */
  public fork<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
      messageID?: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "sessionID" },
            { in: "body", key: "messageID" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<SessionForkResponses, unknown, ThrowOnError>({
      url: "/session/{sessionID}/fork",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Abort session
   *
   * Abort an active session and stop any ongoing AI processing or command execution.
   */
  public abort<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "sessionID" }] }])
    return (options?.client ?? this.client).post<SessionAbortResponses, SessionAbortErrors, ThrowOnError>({
      url: "/session/{sessionID}/abort",
      ...options,
      ...params,
    })
  }

  /**
   * Unshare session
   *
   * Remove the shareable link for a session, making it private again.
   */
  public unshare<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "sessionID" }] }])
    return (options?.client ?? this.client).delete<SessionUnshareResponses, SessionUnshareErrors, ThrowOnError>({
      url: "/session/{sessionID}/share",
      ...options,
      ...params,
    })
  }

  /**
   * Share session
   *
   * Create a shareable link for a session, allowing others to view the conversation.
   */
  public share<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "sessionID" }] }])
    return (options?.client ?? this.client).post<SessionShareResponses, SessionShareErrors, ThrowOnError>({
      url: "/session/{sessionID}/share",
      ...options,
      ...params,
    })
  }

  /**
   * Get message diff
   *
   * Get the file changes (diff) that resulted from a specific user message in the session.
   */
  public diff<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
      messageID?: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "sessionID" },
            { in: "query", key: "messageID" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).get<SessionDiffResponses, unknown, ThrowOnError>({
      url: "/session/{sessionID}/diff",
      ...options,
      ...params,
    })
  }

  /**
   * Get session diff
   *
   * Get all file changes (diffs) made during this session.
   */
  public diffAll<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "sessionID" }] }])
    return (options?.client ?? this.client).get<SessionDiffAllResponses, SessionDiffAllErrors, ThrowOnError>({
      url: "/session/{sessionID}/diff/all",
      ...options,
      ...params,
    })
  }

  /**
   * Summarize session
   *
   * Generate a concise summary of the session using AI compaction to preserve key information.
   */
  public summarize<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
      providerID?: string
      modelID?: string
      auto?: boolean
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "sessionID" },
            { in: "body", key: "providerID" },
            { in: "body", key: "modelID" },
            { in: "body", key: "auto" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<SessionSummarizeResponses, SessionSummarizeErrors, ThrowOnError>({
      url: "/session/{sessionID}/summarize",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Get message
   *
   * Retrieve a specific message from a session by its message ID.
   */
  public message<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
      messageID: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "sessionID" },
            { in: "path", key: "messageID" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).get<SessionMessageResponses, SessionMessageErrors, ThrowOnError>({
      url: "/session/{sessionID}/message/{messageID}",
      ...options,
      ...params,
    })
  }

  /**
   * Send async message
   *
   * Create and send a new message to a session asynchronously, starting the session if needed and returning immediately.
   */
  public promptAsync<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
      messageID?: string
      model?: {
        providerID: string
        modelID: string
      }
      agent?: string
      noReply?: boolean
      tools?: {
        [key: string]: boolean
      }
      system?: string
      options?: {
        [key: string]: unknown
      }
      variant?: string
      parts?: Array<TextPartInput | FilePartInput | AgentPartInput | SubtaskPartInput>
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "sessionID" },
            { in: "body", key: "messageID" },
            { in: "body", key: "model" },
            { in: "body", key: "agent" },
            { in: "body", key: "noReply" },
            { in: "body", key: "tools" },
            { in: "body", key: "system" },
            { in: "body", key: "options" },
            { in: "body", key: "variant" },
            { in: "body", key: "parts" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<SessionPromptAsyncResponses, SessionPromptAsyncErrors, ThrowOnError>({
      url: "/session/{sessionID}/prompt_async",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Send command
   *
   * Send a new command to a session for execution by the AI assistant.
   */
  public command<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
      messageID?: string
      agent?: string
      model?: string
      arguments?: string
      command?: string
      variant?: string
      parts?: Array<{
        id?: string
        type: "file"
        mime: string
        filename?: string
        url: string
        source?: FilePartSource
      }>
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "sessionID" },
            { in: "body", key: "messageID" },
            { in: "body", key: "agent" },
            { in: "body", key: "model" },
            { in: "body", key: "arguments" },
            { in: "body", key: "command" },
            { in: "body", key: "variant" },
            { in: "body", key: "parts" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<SessionCommandResponses, SessionCommandErrors, ThrowOnError>({
      url: "/session/{sessionID}/command",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Run shell command
   *
   * Execute a shell command within the session context and return the AI's response.
   */
  public shell<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
      agent?: string
      model?: {
        providerID: string
        modelID: string
      }
      command?: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "sessionID" },
            { in: "body", key: "agent" },
            { in: "body", key: "model" },
            { in: "body", key: "command" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<SessionShellResponses, SessionShellErrors, ThrowOnError>({
      url: "/session/{sessionID}/shell",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Revert message
   *
   * Revert a specific message in a session, undoing its effects and restoring the previous state.
   */
  public revert<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
      messageID?: string
      partID?: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "sessionID" },
            { in: "body", key: "messageID" },
            { in: "body", key: "partID" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<SessionRevertResponses, SessionRevertErrors, ThrowOnError>({
      url: "/session/{sessionID}/revert",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Restore reverted messages
   *
   * Restore all previously reverted messages in a session.
   */
  public unrevert<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "sessionID" }] }])
    return (options?.client ?? this.client).post<SessionUnrevertResponses, SessionUnrevertErrors, ThrowOnError>({
      url: "/session/{sessionID}/unrevert",
      ...options,
      ...params,
    })
  }

  /**
   * Get session children
   *
   * Retrieve all child sessions that were forked from the specified parent session.
   */
  public children<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "sessionID" }] }])
    return (options?.client ?? this.client).get<SessionChildrenResponses, SessionChildrenErrors, ThrowOnError>({
      url: "/session/{sessionID}/children",
      ...options,
      ...params,
    })
  }

  /**
   * Session event stream (SSE)
   *
   * Subscribe to real-time session events via Server-Sent Events. Streams session updates, messages, and todos for cross-platform sync.
   */
  public events<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "sessionID" }] }])
    return (options?.client ?? this.client).get<SessionEventsResponses, SessionEventsErrors, ThrowOnError>({
      url: "/session/{sessionID}/events",
      ...options,
      ...params,
    })
  }
}

export class Sync extends HeyApiClient {
  /**
   * Sync state for offline clients
   *
   * Get all sessions, messages, and todos updated since a given timestamp. Used for offline-first clients to sync delta changes.
   */
  public delta<ThrowOnError extends boolean = false>(
    parameters?: {
      since?: number
      limit?: number
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "query", key: "since" },
            { in: "query", key: "limit" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).get<SyncDeltaResponses, unknown, ThrowOnError>({
      url: "/sync",
      ...options,
      ...params,
    })
  }
}

export class Part extends HeyApiClient {
  /**
   * Delete a part from a message
   */
  public delete<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
      messageID: string
      partID: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "sessionID" },
            { in: "path", key: "messageID" },
            { in: "path", key: "partID" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).delete<PartDeleteResponses, PartDeleteErrors, ThrowOnError>({
      url: "/session/{sessionID}/message/{messageID}/part/{partID}",
      ...options,
      ...params,
    })
  }

  /**
   * Update a part in a message
   */
  public update<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
      messageID: string
      partID: string
      part?: Part2
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "sessionID" },
            { in: "path", key: "messageID" },
            { in: "path", key: "partID" },
            { key: "part", map: "body" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).patch<PartUpdateResponses, PartUpdateErrors, ThrowOnError>({
      url: "/session/{sessionID}/message/{messageID}/part/{partID}",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }
}

export class Permission extends HeyApiClient {
  /**
   * Respond to permission
   *
   * Approve or deny a permission request from the AI assistant.
   *
   * @deprecated
   */
  public respond<ThrowOnError extends boolean = false>(
    parameters: {
      sessionID: string
      permissionID: string
      response?: "once" | "always" | "reject"
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "sessionID" },
            { in: "path", key: "permissionID" },
            { in: "body", key: "response" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<PermissionRespondResponses, PermissionRespondErrors, ThrowOnError>({
      url: "/session/{sessionID}/permissions/{permissionID}",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Respond to permission request
   *
   * Approve or deny a permission request from the AI assistant.
   */
  public reply<ThrowOnError extends boolean = false>(
    parameters: {
      requestID: string
      reply?: "once" | "always" | "reject"
      message?: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "requestID" },
            { in: "body", key: "reply" },
            { in: "body", key: "message" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<PermissionReplyResponses, PermissionReplyErrors, ThrowOnError>({
      url: "/permission/{requestID}/reply",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * List pending permissions
   *
   * Get all pending permission requests across all sessions.
   */
  public list<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<PermissionListResponses, unknown, ThrowOnError>({
      url: "/permission",
      ...options,
    })
  }
}

export class Personas extends HeyApiClient {
  /**
   * List available personas
   *
   * Get list of available personas (Zee, Stanley, Johny) with their status and capabilities.
   */
  public list<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<PersonasListResponses, unknown, ThrowOnError>({
      url: "/personas",
      ...options,
    })
  }
}

export class Events extends HeyApiClient {
  /**
   * Global event stream (SSE)
   *
   * Subscribe to all session events via Server-Sent Events. Useful for dashboards and cross-platform monitoring.
   */
  public global<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<EventsGlobalResponses, unknown, ThrowOnError>({
      url: "/events",
      ...options,
    })
  }
}

export class Command extends HeyApiClient {
  /**
   * List commands
   *
   * Get a list of all available commands in the agent-core system.
   */
  public list<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<CommandListResponses, unknown, ThrowOnError>({
      url: "/command",
      ...options,
    })
  }
}

export class Auth extends HeyApiClient {
  /**
   * Get provider auth status
   *
   * Retrieve the current authentication status for all providers with OAuth tokens.
   */
  public status<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<ProviderAuthStatusResponses, unknown, ThrowOnError>({
      url: "/provider/auth/status",
      ...options,
    })
  }
}

export class Oauth extends HeyApiClient {
  /**
   * OAuth authorize
   *
   * Initiate OAuth authorization for a specific AI provider to get an authorization URL.
   */
  public authorize<ThrowOnError extends boolean = false>(
    parameters: {
      providerID: string
      method?: number
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "providerID" },
            { in: "body", key: "method" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<
      ProviderOauthAuthorizeResponses,
      ProviderOauthAuthorizeErrors,
      ThrowOnError
    >({
      url: "/provider/{providerID}/oauth/authorize",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * OAuth callback
   *
   * Handle the OAuth callback from a provider after user authorization.
   */
  public callback<ThrowOnError extends boolean = false>(
    parameters: {
      providerID: string
      method?: number
      code?: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "providerID" },
            { in: "body", key: "method" },
            { in: "body", key: "code" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<
      ProviderOauthCallbackResponses,
      ProviderOauthCallbackErrors,
      ThrowOnError
    >({
      url: "/provider/{providerID}/oauth/callback",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }
}

export class Provider extends HeyApiClient {
  /**
   * List providers
   *
   * Get a list of all available AI providers, including both available and connected ones.
   */
  public list<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<ProviderListResponses, unknown, ThrowOnError>({
      url: "/provider",
      ...options,
    })
  }

  /**
   * Get provider auth methods
   *
   * Retrieve available authentication methods for all AI providers.
   */
  public auth<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<ProviderAuthResponses, unknown, ThrowOnError>({
      url: "/provider/auth",
      ...options,
    })
  }

  private _auth?: Auth
  get auth2(): Auth {
    return (this._auth ??= new Auth({ client: this.client }))
  }

  private _oauth?: Oauth
  get oauth(): Oauth {
    return (this._oauth ??= new Oauth({ client: this.client }))
  }
}

export class Tool extends HeyApiClient {
  /**
   * Call MCP tool
   *
   * Execute a tool on a connected MCP server.
   */
  public call<ThrowOnError extends boolean = false>(
    parameters: {
      name: string
      tool?: string
      arguments?: {
        [key: string]: unknown
      }
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "name" },
            { in: "body", key: "tool" },
            { in: "body", key: "arguments" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<McpToolCallResponses, McpToolCallErrors, ThrowOnError>({
      url: "/mcp/{name}/tool",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }
}

export class Auth2 extends HeyApiClient {
  /**
   * Remove MCP OAuth
   *
   * Remove OAuth credentials for an MCP server
   */
  public remove<ThrowOnError extends boolean = false>(
    parameters: {
      name: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "name" }] }])
    return (options?.client ?? this.client).delete<McpAuthRemoveResponses, McpAuthRemoveErrors, ThrowOnError>({
      url: "/mcp/{name}/auth",
      ...options,
      ...params,
    })
  }

  /**
   * Start MCP OAuth
   *
   * Start OAuth authentication flow for a Model Context Protocol (MCP) server.
   */
  public start<ThrowOnError extends boolean = false>(
    parameters: {
      name: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "name" }] }])
    return (options?.client ?? this.client).post<McpAuthStartResponses, McpAuthStartErrors, ThrowOnError>({
      url: "/mcp/{name}/auth",
      ...options,
      ...params,
    })
  }

  /**
   * Complete MCP OAuth
   *
   * Complete OAuth authentication for a Model Context Protocol (MCP) server using the authorization code.
   */
  public callback<ThrowOnError extends boolean = false>(
    parameters: {
      name: string
      code?: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "name" },
            { in: "body", key: "code" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<McpAuthCallbackResponses, McpAuthCallbackErrors, ThrowOnError>({
      url: "/mcp/{name}/auth/callback",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Authenticate MCP OAuth
   *
   * Start OAuth flow and wait for callback (opens browser)
   */
  public authenticate<ThrowOnError extends boolean = false>(
    parameters: {
      name: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "name" }] }])
    return (options?.client ?? this.client).post<McpAuthAuthenticateResponses, McpAuthAuthenticateErrors, ThrowOnError>(
      {
        url: "/mcp/{name}/auth/authenticate",
        ...options,
        ...params,
      },
    )
  }
}

export class Mcp extends HeyApiClient {
  /**
   * Get MCP status
   *
   * Get the status of all Model Context Protocol (MCP) servers.
   */
  public status<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<McpStatusResponses, unknown, ThrowOnError>({ url: "/mcp", ...options })
  }

  /**
   * Add MCP server
   *
   * Dynamically add a new Model Context Protocol (MCP) server to the system.
   */
  public add<ThrowOnError extends boolean = false>(
    parameters?: {
      name?: string
      config?: McpLocalConfig | McpRemoteConfig
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "body", key: "name" },
            { in: "body", key: "config" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<McpAddResponses, McpAddErrors, ThrowOnError>({
      url: "/mcp",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Connect an MCP server
   */
  public connect<ThrowOnError extends boolean = false>(
    parameters: {
      name: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "name" }] }])
    return (options?.client ?? this.client).post<McpConnectResponses, unknown, ThrowOnError>({
      url: "/mcp/{name}/connect",
      ...options,
      ...params,
    })
  }

  /**
   * Disconnect an MCP server
   */
  public disconnect<ThrowOnError extends boolean = false>(
    parameters: {
      name: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "name" }] }])
    return (options?.client ?? this.client).post<McpDisconnectResponses, unknown, ThrowOnError>({
      url: "/mcp/{name}/disconnect",
      ...options,
      ...params,
    })
  }

  /**
   * Reconnect an MCP server
   *
   * Attempt to reconnect to an MCP server that has failed or disconnected.
   */
  public reconnect<ThrowOnError extends boolean = false>(
    parameters: {
      name: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "name" }] }])
    return (options?.client ?? this.client).post<McpReconnectResponses, unknown, ThrowOnError>({
      url: "/mcp/{name}/reconnect",
      ...options,
      ...params,
    })
  }

  /**
   * Reconnect all failed MCP servers
   *
   * Attempt to reconnect to all MCP servers that are in a failed state.
   */
  public reconnectAll<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).post<McpReconnectAllResponses, unknown, ThrowOnError>({
      url: "/mcp/reconnect-all",
      ...options,
    })
  }

  /**
   * Health check and reconnect MCP servers
   *
   * Check health of all connected MCPs and attempt to reconnect any that have failed.
   */
  public healthCheckAndReconnect<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).post<McpHealthCheckAndReconnectResponses, unknown, ThrowOnError>({
      url: "/mcp/health-check",
      ...options,
    })
  }

  private _tool?: Tool
  get tool(): Tool {
    return (this._tool ??= new Tool({ client: this.client }))
  }

  private _auth?: Auth2
  get auth(): Auth2 {
    return (this._auth ??= new Auth2({ client: this.client }))
  }
}

export class Resource extends HeyApiClient {
  /**
   * Get MCP resources
   *
   * Get all available MCP resources from connected servers. Optionally filter by name.
   */
  public list<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<ExperimentalResourceListResponses, unknown, ThrowOnError>({
      url: "/mcp/experimental/resource",
      ...options,
    })
  }
}

export class Experimental extends HeyApiClient {
  private _resource?: Resource
  get resource(): Resource {
    return (this._resource ??= new Resource({ client: this.client }))
  }
}

export class Lsp extends HeyApiClient {
  /**
   * Get LSP status
   *
   * Get LSP server status
   */
  public status<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<LspStatusResponses, unknown, ThrowOnError>({ url: "/lsp", ...options })
  }
}

export class Formatter extends HeyApiClient {
  /**
   * Get formatter status
   *
   * Get formatter status
   */
  public status<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<FormatterStatusResponses, unknown, ThrowOnError>({
      url: "/formatter",
      ...options,
    })
  }
}

export class Tui extends HeyApiClient {
  /**
   * Append TUI prompt
   *
   * Append prompt to the TUI
   */
  public appendPrompt<ThrowOnError extends boolean = false>(
    parameters?: {
      text?: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "body", key: "text" }] }])
    return (options?.client ?? this.client).post<TuiAppendPromptResponses, TuiAppendPromptErrors, ThrowOnError>({
      url: "/tui/append-prompt",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Open help dialog
   *
   * Open the help dialog in the TUI to display user assistance information.
   */
  public openHelp<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).post<TuiOpenHelpResponses, unknown, ThrowOnError>({
      url: "/tui/open-help",
      ...options,
    })
  }

  /**
   * Open sessions dialog
   *
   * Open the session dialog
   */
  public openSessions<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).post<TuiOpenSessionsResponses, unknown, ThrowOnError>({
      url: "/tui/open-sessions",
      ...options,
    })
  }

  /**
   * Open themes dialog
   *
   * Open the theme dialog
   */
  public openThemes<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).post<TuiOpenThemesResponses, unknown, ThrowOnError>({
      url: "/tui/open-themes",
      ...options,
    })
  }

  /**
   * Open models dialog
   *
   * Open the model dialog
   */
  public openModels<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).post<TuiOpenModelsResponses, unknown, ThrowOnError>({
      url: "/tui/open-models",
      ...options,
    })
  }

  /**
   * Submit TUI prompt
   *
   * Submit the prompt
   */
  public submitPrompt<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).post<TuiSubmitPromptResponses, unknown, ThrowOnError>({
      url: "/tui/submit-prompt",
      ...options,
    })
  }

  /**
   * Clear TUI prompt
   *
   * Clear the prompt
   */
  public clearPrompt<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).post<TuiClearPromptResponses, unknown, ThrowOnError>({
      url: "/tui/clear-prompt",
      ...options,
    })
  }

  /**
   * Execute TUI command
   *
   * Execute a TUI command (e.g. agent_cycle)
   */
  public executeCommand<ThrowOnError extends boolean = false>(
    parameters?: {
      command?: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "body", key: "command" }] }])
    return (options?.client ?? this.client).post<TuiExecuteCommandResponses, TuiExecuteCommandErrors, ThrowOnError>({
      url: "/tui/execute-command",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Show TUI toast
   *
   * Show a toast notification in the TUI
   */
  public showToast<ThrowOnError extends boolean = false>(
    parameters?: {
      title?: string
      message?: string
      variant?: "info" | "success" | "warning" | "error"
      duration?: number
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "body", key: "title" },
            { in: "body", key: "message" },
            { in: "body", key: "variant" },
            { in: "body", key: "duration" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<TuiShowToastResponses, unknown, ThrowOnError>({
      url: "/tui/show-toast",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Publish TUI event
   *
   * Publish a TUI event
   */
  public publish<ThrowOnError extends boolean = false>(
    parameters?: {
      body?: EventTuiPromptAppend | EventTuiCommandExecute | EventTuiToastShow | EventTuiSessionSelect
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "body" }] }])
    return (options?.client ?? this.client).post<TuiPublishResponses, TuiPublishErrors, ThrowOnError>({
      url: "/tui/publish",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Select session
   *
   * Navigate the TUI to display the specified session.
   */
  public selectSession<ThrowOnError extends boolean = false>(
    parameters?: {
      sessionID?: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "body", key: "sessionID" }] }])
    return (options?.client ?? this.client).post<TuiSelectSessionResponses, TuiSelectSessionErrors, ThrowOnError>({
      url: "/tui/select-session",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }
}

export class Auth3 extends HeyApiClient {
  /**
   * Remove auth credentials
   *
   * Remove authentication credentials
   */
  public remove<ThrowOnError extends boolean = false>(
    parameters: {
      providerID: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "providerID" }] }])
    return (options?.client ?? this.client).delete<AuthRemoveResponses, AuthRemoveErrors, ThrowOnError>({
      url: "/auth/{providerID}",
      ...options,
      ...params,
    })
  }

  /**
   * Set auth credentials
   *
   * Set authentication credentials
   */
  public set<ThrowOnError extends boolean = false>(
    parameters: {
      providerID: string
      body?:
        | Auth4
        | {
            api_key: string
          }
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "providerID" }, { in: "body" }] }])
    return (options?.client ?? this.client).put<AuthSetResponses, AuthSetErrors, ThrowOnError>({
      url: "/auth/{providerID}",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }
}

export class Tool2 extends HeyApiClient {
  /**
   * List tool IDs
   *
   * Get a list of all available tool IDs, including both built-in tools and dynamically registered tools.
   */
  public ids<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<ToolIdsResponses, ToolIdsErrors, ThrowOnError>({
      url: "/ids",
      ...options,
    })
  }

  /**
   * List tools
   *
   * Get a list of available tools with their JSON schema parameters for a specific provider and model combination.
   */
  public list<ThrowOnError extends boolean = false>(
    parameters: {
      provider: string
      model: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "query", key: "provider" },
            { in: "query", key: "model" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).get<ToolListResponses, ToolListErrors, ThrowOnError>({
      url: "/",
      ...options,
      ...params,
    })
  }
}

export class Question extends HeyApiClient {
  /**
   * List pending questions
   *
   * Get all pending question requests across all sessions.
   */
  public list<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<QuestionListResponses, unknown, ThrowOnError>({
      url: "/question",
      ...options,
    })
  }

  /**
   * Reply to question request
   *
   * Provide answers to a question request from the AI assistant.
   */
  public reply<ThrowOnError extends boolean = false>(
    parameters: {
      requestID: string
      answers?: Array<QuestionAnswer>
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "requestID" },
            { in: "body", key: "answers" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<QuestionReplyResponses, QuestionReplyErrors, ThrowOnError>({
      url: "/question/{requestID}/reply",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Reject question request
   *
   * Reject a question request from the AI assistant.
   */
  public reject<ThrowOnError extends boolean = false>(
    parameters: {
      requestID: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "requestID" }] }])
    return (options?.client ?? this.client).post<QuestionRejectResponses, QuestionRejectErrors, ThrowOnError>({
      url: "/question/{requestID}/reject",
      ...options,
      ...params,
    })
  }
}

export class Project extends HeyApiClient {
  /**
   * List all projects
   *
   * Get a list of projects that have been opened with agent-core.
   */
  public list<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<ProjectListResponses, unknown, ThrowOnError>({
      url: "/project",
      ...options,
    })
  }

  /**
   * Get current project
   *
   * Retrieve the currently active project that agent-core is working with.
   */
  public current<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<ProjectCurrentResponses, unknown, ThrowOnError>({
      url: "/project/current",
      ...options,
    })
  }

  /**
   * Update project
   *
   * Update project properties such as name, icon and color.
   */
  public update<ThrowOnError extends boolean = false>(
    parameters: {
      projectID: string
      name?: string
      icon?: {
        url?: string
        override?: string
        color?: string
      }
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "projectID" },
            { in: "body", key: "name" },
            { in: "body", key: "icon" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).patch<ProjectUpdateResponses, ProjectUpdateErrors, ThrowOnError>({
      url: "/project/{projectID}",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }
}

export class Process extends HeyApiClient {
  /**
   * Register process
   *
   * Register a new agent, swarm, worker, or daemon process with the central registry.
   */
  public register<ThrowOnError extends boolean = false>(
    parameters?: {
      id?: string
      type?: "agent" | "swarm" | "worker" | "daemon" | "queen"
      name?: string
      swarmId?: string
      parentId?: string
      capabilities?: Array<string>
      metadata?: {
        [key: string]: unknown
      }
      host?: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "body", key: "id" },
            { in: "body", key: "type" },
            { in: "body", key: "name" },
            { in: "body", key: "swarmId" },
            { in: "body", key: "parentId" },
            { in: "body", key: "capabilities" },
            { in: "body", key: "metadata" },
            { in: "body", key: "host" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<ProcessRegisterResponses, ProcessRegisterErrors, ThrowOnError>({
      url: "/process/register",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * List processes
   *
   * Get a list of all registered processes with optional filters.
   */
  public list<ThrowOnError extends boolean = false>(
    parameters?: {
      type?: "agent" | "swarm" | "worker" | "daemon" | "queen"
      swarmId?: string
      status?: "active" | "busy" | "idle" | "offline" | "error"
      parentId?: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "query", key: "type" },
            { in: "query", key: "swarmId" },
            { in: "query", key: "status" },
            { in: "query", key: "parentId" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).get<ProcessListResponses, unknown, ThrowOnError>({
      url: "/process",
      ...options,
      ...params,
    })
  }

  /**
   * Get process statistics
   *
   * Get statistics about registered processes by type and status.
   */
  public stats<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<ProcessStatsResponses, unknown, ThrowOnError>({
      url: "/process/stats",
      ...options,
    })
  }

  /**
   * Process events stream (SSE)
   *
   * Subscribe to real-time process events via Server-Sent Events.
   */
  public events<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<ProcessEventsResponses, unknown, ThrowOnError>({
      url: "/process/events",
      ...options,
    })
  }

  /**
   * Get swarm processes
   *
   * Get all processes belonging to a specific swarm.
   */
  public bySwarm<ThrowOnError extends boolean = false>(
    parameters: {
      swarmId: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "swarmId" }] }])
    return (options?.client ?? this.client).get<ProcessBySwarmResponses, unknown, ThrowOnError>({
      url: "/process/swarm/{swarmId}",
      ...options,
      ...params,
    })
  }

  /**
   * Find available agents
   *
   * Find idle agents with specific capabilities.
   */
  public findAvailable<ThrowOnError extends boolean = false>(
    parameters?: {
      capabilities?: Array<string>
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "body", key: "capabilities" }] }])
    return (options?.client ?? this.client).post<ProcessFindAvailableResponses, unknown, ThrowOnError>({
      url: "/process/find-available",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Deregister process
   *
   * Remove a process from the registry.
   */
  public deregister<ThrowOnError extends boolean = false>(
    parameters: {
      id: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "id" }] }])
    return (options?.client ?? this.client).delete<ProcessDeregisterResponses, ProcessDeregisterErrors, ThrowOnError>({
      url: "/process/{id}",
      ...options,
      ...params,
    })
  }

  /**
   * Get process
   *
   * Get detailed information about a specific process.
   */
  public get<ThrowOnError extends boolean = false>(
    parameters: {
      id: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "id" }] }])
    return (options?.client ?? this.client).get<ProcessGetResponses, ProcessGetErrors, ThrowOnError>({
      url: "/process/{id}",
      ...options,
      ...params,
    })
  }

  /**
   * Update process
   *
   * Update process status, current task, or other information.
   */
  public update<ThrowOnError extends boolean = false>(
    parameters: {
      id: string
      status?: "active" | "busy" | "idle" | "offline" | "error"
      currentTask?: string | null
      capabilities?: Array<string>
      metadata?: {
        [key: string]: unknown
      }
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "id" },
            { in: "body", key: "status" },
            { in: "body", key: "currentTask" },
            { in: "body", key: "capabilities" },
            { in: "body", key: "metadata" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).patch<ProcessUpdateResponses, ProcessUpdateErrors, ThrowOnError>({
      url: "/process/{id}",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Process heartbeat
   *
   * Update the heartbeat timestamp for a process to indicate it's still alive.
   */
  public heartbeat<ThrowOnError extends boolean = false>(
    parameters: {
      id: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "id" }] }])
    return (options?.client ?? this.client).post<ProcessHeartbeatResponses, ProcessHeartbeatErrors, ThrowOnError>({
      url: "/process/{id}/heartbeat",
      ...options,
      ...params,
    })
  }
}

export class Memory extends HeyApiClient {
  /**
   * Store memory
   *
   * Store a new memory entry with semantic embedding.
   */
  public store<ThrowOnError extends boolean = false>(
    parameters?: {
      category?:
        | "conversation"
        | "fact"
        | "preference"
        | "task"
        | "decision"
        | "relationship"
        | "note"
        | "pattern"
        | "custom"
      content?: string
      summary?: string
      metadata?: {
        surface?: string
        sessionId?: string
        agent?: string
        importance?: number
        entities?: Array<string>
        tags?: Array<string>
        extra?: {
          [key: string]: unknown
        }
      }
      ttl?: number
      namespace?: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "body", key: "category" },
            { in: "body", key: "content" },
            { in: "body", key: "summary" },
            { in: "body", key: "metadata" },
            { in: "body", key: "ttl" },
            { in: "body", key: "namespace" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<MemoryStoreResponses, MemoryStoreErrors, ThrowOnError>({
      url: "/memory/store",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Batch store memories
   *
   * Store multiple memory entries at once.
   */
  public batch<ThrowOnError extends boolean = false>(
    parameters?: {
      entries?: Array<{
        category:
          | "conversation"
          | "fact"
          | "preference"
          | "task"
          | "decision"
          | "relationship"
          | "note"
          | "pattern"
          | "custom"
        content: string
        summary?: string
        metadata?: {
          surface?: string
          sessionId?: string
          agent?: string
          importance?: number
          entities?: Array<string>
          tags?: Array<string>
          extra?: {
            [key: string]: unknown
          }
        }
        ttl?: number
        namespace?: string
      }>
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "body", key: "entries" }] }])
    return (options?.client ?? this.client).post<MemoryBatchResponses, MemoryBatchErrors, ThrowOnError>({
      url: "/memory/batch",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Search memories
   *
   * Semantic search across memory entries.
   */
  public search<ThrowOnError extends boolean = false>(
    parameters?: {
      query?: string
      limit?: number
      threshold?: number
      category?:
        | "conversation"
        | "fact"
        | "preference"
        | "task"
        | "decision"
        | "relationship"
        | "note"
        | "pattern"
        | "custom"
        | Array<
            | "conversation"
            | "fact"
            | "preference"
            | "task"
            | "decision"
            | "relationship"
            | "note"
            | "pattern"
            | "custom"
          >
      namespace?: string | null
      tags?: Array<string>
      timeRange?: {
        start?: number
        end?: number
      }
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "body", key: "query" },
            { in: "body", key: "limit" },
            { in: "body", key: "threshold" },
            { in: "body", key: "category" },
            { in: "body", key: "namespace" },
            { in: "body", key: "tags" },
            { in: "body", key: "timeRange" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<MemorySearchResponses, MemorySearchErrors, ThrowOnError>({
      url: "/memory/search",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Get memory statistics
   *
   * Get statistics about stored memories.
   */
  public stats<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<MemoryStatsResponses, unknown, ThrowOnError>({
      url: "/memory/stats",
      ...options,
    })
  }

  /**
   * Memory health check
   *
   * Check if the memory service is available and connected.
   */
  public health<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<MemoryHealthResponses, unknown, ThrowOnError>({
      url: "/memory/health",
      ...options,
    })
  }

  /**
   * Delete memory
   *
   * Delete a specific memory entry.
   */
  public delete<ThrowOnError extends boolean = false>(
    parameters: {
      id: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "id" }] }])
    return (options?.client ?? this.client).delete<MemoryDeleteResponses, unknown, ThrowOnError>({
      url: "/memory/{id}",
      ...options,
      ...params,
    })
  }

  /**
   * Get memory
   *
   * Get a specific memory entry by ID.
   */
  public get<ThrowOnError extends boolean = false>(
    parameters: {
      id: string
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams([parameters], [{ args: [{ in: "path", key: "id" }] }])
    return (options?.client ?? this.client).get<MemoryGetResponses, MemoryGetErrors, ThrowOnError>({
      url: "/memory/{id}",
      ...options,
      ...params,
    })
  }

  /**
   * List memories by namespace
   *
   * Get all memories in a specific namespace.
   */
  public byNamespace<ThrowOnError extends boolean = false>(
    parameters: {
      namespace: string
      category?:
        | "conversation"
        | "fact"
        | "preference"
        | "task"
        | "decision"
        | "relationship"
        | "note"
        | "pattern"
        | "custom"
      limit?: number
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "path", key: "namespace" },
            { in: "query", key: "category" },
            { in: "query", key: "limit" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).get<MemoryByNamespaceResponses, unknown, ThrowOnError>({
      url: "/memory/namespace/{namespace}",
      ...options,
      ...params,
    })
  }

  /**
   * Delete memories by filter
   *
   * Delete memories matching the specified criteria.
   */
  public deleteWhere<ThrowOnError extends boolean = false>(
    parameters?: {
      category?:
        | "conversation"
        | "fact"
        | "preference"
        | "task"
        | "decision"
        | "relationship"
        | "note"
        | "pattern"
        | "custom"
      namespace?: string
      olderThan?: number
    },
    options?: Options<never, ThrowOnError>,
  ) {
    const params = buildClientParams(
      [parameters],
      [
        {
          args: [
            { in: "body", key: "category" },
            { in: "body", key: "namespace" },
            { in: "body", key: "olderThan" },
          ],
        },
      ],
    )
    return (options?.client ?? this.client).post<MemoryDeleteWhereResponses, MemoryDeleteWhereErrors, ThrowOnError>({
      url: "/memory/delete-where",
      ...options,
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
        ...params.headers,
      },
    })
  }

  /**
   * Cleanup expired memories
   *
   * Delete all expired memory entries based on TTL.
   */
  public cleanup<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).post<MemoryCleanupResponses, unknown, ThrowOnError>({
      url: "/memory/cleanup",
      ...options,
    })
  }

  /**
   * Reset memory service
   *
   * Reset the memory service state and retry initialization. Use this if memory init failed.
   */
  public reset<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).post<MemoryResetResponses, unknown, ThrowOnError>({
      url: "/memory/reset",
      ...options,
    })
  }
}

export class Whatsapp extends HeyApiClient {
  /**
   * Send WhatsApp message (via Zee gateway)
   *
   * Send a WhatsApp message via the local Zee gateway (WebSocket RPC).
   */
  public send<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).post<GatewayWhatsappSendResponses, unknown, ThrowOnError>({
      url: "/gateway/whatsapp/send",
      ...options,
    })
  }
}

export class Telegram extends HeyApiClient {
  /**
   * Send Telegram message (via Zee gateway)
   *
   * Send a Telegram message via the local Zee gateway (WebSocket RPC).
   */
  public send<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).post<GatewayTelegramSendResponses, unknown, ThrowOnError>({
      url: "/gateway/telegram/send",
      ...options,
    })
  }
}

export class Gateway extends HeyApiClient {
  private _whatsapp?: Whatsapp
  get whatsapp(): Whatsapp {
    return (this._whatsapp ??= new Whatsapp({ client: this.client }))
  }

  private _telegram?: Telegram
  get telegram(): Telegram {
    return (this._telegram ??= new Telegram({ client: this.client }))
  }
}

export class Openapi extends HeyApiClient {
  /**
   * Get OpenAPI specs
   *
   * Get the OpenAPI specifications for the API.
   */
  public specs<ThrowOnError extends boolean = false>(options?: Options<never, ThrowOnError>) {
    return (options?.client ?? this.client).get<OpenapiSpecsResponses, unknown, ThrowOnError>({
      url: "/openapi",
      ...options,
    })
  }
}

export class OpencodeClient extends HeyApiClient {
  public static readonly __registry = new HeyApiRegistry<OpencodeClient>()

  constructor(args?: { client?: Client; key?: string }) {
    super(args)
    OpencodeClient.__registry.set(this, args?.key)
  }

  private _event?: Event
  get event(): Event {
    return (this._event ??= new Event({ client: this.client }))
  }

  private _app?: App
  get app(): App {
    return (this._app ??= new App({ client: this.client }))
  }

  private _health?: Health
  get health(): Health {
    return (this._health ??= new Health({ client: this.client }))
  }

  private _instance?: Instance
  get instance(): Instance {
    return (this._instance ??= new Instance({ client: this.client }))
  }

  private _pty?: Pty
  get pty(): Pty {
    return (this._pty ??= new Pty({ client: this.client }))
  }

  private _config?: Config
  get config(): Config {
    return (this._config ??= new Config({ client: this.client }))
  }

  private _themes?: Themes
  get themes(): Themes {
    return (this._themes ??= new Themes({ client: this.client }))
  }

  private _preferences?: Preferences
  get preferences(): Preferences {
    return (this._preferences ??= new Preferences({ client: this.client }))
  }

  private _path?: Path
  get path(): Path {
    return (this._path ??= new Path({ client: this.client }))
  }

  private _worktree?: Worktree
  get worktree(): Worktree {
    return (this._worktree ??= new Worktree({ client: this.client }))
  }

  private _vcs?: Vcs
  get vcs(): Vcs {
    return (this._vcs ??= new Vcs({ client: this.client }))
  }

  private _find?: Find
  get find(): Find {
    return (this._find ??= new Find({ client: this.client }))
  }

  private _file?: File
  get file(): File {
    return (this._file ??= new File({ client: this.client }))
  }

  private _session?: Session
  get session(): Session {
    return (this._session ??= new Session({ client: this.client }))
  }

  private _sync?: Sync
  get sync(): Sync {
    return (this._sync ??= new Sync({ client: this.client }))
  }

  private _part?: Part
  get part(): Part {
    return (this._part ??= new Part({ client: this.client }))
  }

  private _permission?: Permission
  get permission(): Permission {
    return (this._permission ??= new Permission({ client: this.client }))
  }

  private _personas?: Personas
  get personas(): Personas {
    return (this._personas ??= new Personas({ client: this.client }))
  }

  private _events?: Events
  get events(): Events {
    return (this._events ??= new Events({ client: this.client }))
  }

  private _command?: Command
  get command(): Command {
    return (this._command ??= new Command({ client: this.client }))
  }

  private _provider?: Provider
  get provider(): Provider {
    return (this._provider ??= new Provider({ client: this.client }))
  }

  private _mcp?: Mcp
  get mcp(): Mcp {
    return (this._mcp ??= new Mcp({ client: this.client }))
  }

  private _experimental?: Experimental
  get experimental(): Experimental {
    return (this._experimental ??= new Experimental({ client: this.client }))
  }

  private _lsp?: Lsp
  get lsp(): Lsp {
    return (this._lsp ??= new Lsp({ client: this.client }))
  }

  private _formatter?: Formatter
  get formatter(): Formatter {
    return (this._formatter ??= new Formatter({ client: this.client }))
  }

  private _tui?: Tui
  get tui(): Tui {
    return (this._tui ??= new Tui({ client: this.client }))
  }

  private _auth?: Auth3
  get auth(): Auth3 {
    return (this._auth ??= new Auth3({ client: this.client }))
  }

  private _tool?: Tool2
  get tool(): Tool2 {
    return (this._tool ??= new Tool2({ client: this.client }))
  }

  private _question?: Question
  get question(): Question {
    return (this._question ??= new Question({ client: this.client }))
  }

  private _project?: Project
  get project(): Project {
    return (this._project ??= new Project({ client: this.client }))
  }

  private _process?: Process
  get process(): Process {
    return (this._process ??= new Process({ client: this.client }))
  }

  private _memory?: Memory
  get memory(): Memory {
    return (this._memory ??= new Memory({ client: this.client }))
  }

  private _gateway?: Gateway
  get gateway(): Gateway {
    return (this._gateway ??= new Gateway({ client: this.client }))
  }

  private _openapi?: Openapi
  get openapi(): Openapi {
    return (this._openapi ??= new Openapi({ client: this.client }))
  }
}
